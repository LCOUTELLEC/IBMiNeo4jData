// =====================================================
// SCRIPT COMPLET DE CHARGEMENT NEO4J - PATRIMOINE IBMi
// =====================================================

// =========== PHASE 1: NETTOYAGE ET INITIALISATION ===========

// Nettoyage complet de la base (ATTENTION: supprime tout!)
MATCH (n) DETACH DELETE n;

// Création des contraintes d'unicité
CREATE CONSTRAINT FOR (n:Programme) REQUIRE (n.name, n.library) IS UNIQUE;
CREATE CONSTRAINT FOR (n:Table) REQUIRE (n.name, n.library) IS UNIQUE;
CREATE CONSTRAINT FOR (n:Source) REQUIRE (n.name, n.library, n.sourceFile) IS UNIQUE;
CREATE CONSTRAINT FOR (n:Application) REQUIRE (n.name) IS UNIQUE;
CREATE CONSTRAINT FOR (n:TypeObjIBMi) REQUIRE (n.name) IS UNIQUE;
CREATE CONSTRAINT FOR (n:TypeObjARCAD) REQUIRE (n.name) IS UNIQUE;
CREATE CONSTRAINT FOR (n:Attribut) REQUIRE (n.name) IS UNIQUE;

// Création des index pour optimiser les performances
CREATE INDEX FOR (n:Programme) ON (n.name, n.library);
CREATE INDEX FOR (n:Table) ON (n.name, n.library);
CREATE INDEX FOR (n:Source) ON (n.name, n.library);
CREATE INDEX FOR (n:Programme) ON (n.attribute);
CREATE INDEX FOR (n:Table) ON (n.attribute);

// =========== PHASE 2: CHARGEMENT DES MÉTADONNÉES ===========

// 2.1 Types IBMi (à adapter selon vos données)
MERGE (type:TypeObjIBMi {name: '*PGM'}) SET type.description = 'Programme exécutable';
MERGE (type:TypeObjIBMi {name: '*FILE'}) SET type.description = 'Fichier (physique, logique, etc.)';
MERGE (type:TypeObjIBMi {name: '*SRVPGM'}) SET type.description = 'Service Program';
MERGE (type:TypeObjIBMi {name: '*MODULE'}) SET type.description = 'Module non lié';
MERGE (type:TypeObjIBMi {name: '*CMD'}) SET type.description = 'Commande';
MERGE (type:TypeObjIBMi {name: '*MSGF'}) SET type.description = 'Message File';
MERGE (type:TypeObjIBMi {name: '*DTAARA'}) SET type.description = 'Data Area';
MERGE (type:TypeObjIBMi {name: '*QRYDFN'}) SET type.description = 'Query Definition';

// 2.2 Types ARCAD (à adapter selon vos données)
MERGE (type:TypeObjARCAD {name: '*PF'}) SET type.description = 'Physical File ARCAD';
MERGE (type:TypeObjARCAD {name: '*PFTAB'}) SET type.description = 'Table Physical File ARCAD';
MERGE (type:TypeObjARCAD {name: '*LF'}) SET type.description = 'Logical File ARCAD';

// 2.3 Attributs (à adapter selon vos données)
MERGE (attr:Attribut {name: 'RPG'}) SET attr.description = 'Programme RPG';
MERGE (attr:Attribut {name: 'RPGLE'}) SET attr.description = 'Programme RPG ILE';
MERGE (attr:Attribut {name: 'SQLRPG'}) SET attr.description = 'Programme RPG avec SQL';
MERGE (attr:Attribut {name: 'SQLRPGLE'}) SET attr.description = 'Programme RPG ILE avec SQL';
MERGE (attr:Attribut {name: 'CLP'}) SET attr.description = 'Control Language Program';
MERGE (attr:Attribut {name: 'CLLE'}) SET attr.description = 'Control Language Program ILE';
MERGE (attr:Attribut {name: 'CBL'}) SET attr.description = 'Programme COBOL';
MERGE (attr:Attribut {name: 'PF'}) SET attr.description = 'Physical File';
MERGE (attr:Attribut {name: 'TABLE'}) SET attr.description = 'Table SQL';
MERGE (attr:Attribut {name: 'LF'}) SET attr.description = 'Logical File';

// =========== PHASE 3: CHARGEMENT DES APPLICATIONS ===========

// 3.1 Applications (extraction des valeurs uniques depuis les objets)
LOAD CSV WITH HEADERS FROM 'file:///IBMi_RefArcaddesObjets.csv' AS row
WITH DISTINCT trim(row.LST_CAPP) AS appName
WHERE appName IS NOT NULL AND appName <> ''
MERGE (app:Application {name: appName});

// =========== PHASE 4: CHARGEMENT DES SOURCES ===========

// 4.1 Sources filtrées (programmes et tables uniquement)
LOAD CSV WITH HEADERS FROM 'file:///IBMi_RefArcaddesSources.csv' AS row
WITH row 
WHERE row.LST_CELTTY = 'M' 
  AND (
    trim(row.LST_CTYPE) IN ['RPG', 'RPGLE', 'SQLRPG', 'SQLRPGLE', 'CLP', 'CLLE', 'CBL'] 
    OR trim(row.LST_JSRCF) IN ['QDDSSRC', 'QSQLSRC']
    OR trim(row.LST_CTYPE) = '*FILE'
  )
MERGE (src:Source {
    name: trim(row.LST_JOBJ), 
    library: trim(row.LST_JLIB),
    sourceFile: trim(row.LST_JSRCF)
})
SET src.sourceType = trim(row.LST_CTYPE),
    src.description = trim(row.LST_CTXT),
    src.lastModified = CASE 
        WHEN row.LST_TDATE IS NOT NULL AND toString(row.LST_TDATE) <> '' 
        THEN date(substring(toString(row.LST_TDATE), 0, 4) + '-' + 
                  substring(toString(row.LST_TDATE), 4, 2) + '-' + 
                  substring(toString(row.LST_TDATE), 6, 2))
        ELSE null 
    END,
    src.lineCount = CASE 
        WHEN row.LST_JZSEL1 IS NOT NULL 
        THEN toInteger(row.LST_JZSEL1) 
        ELSE 0 
    END;

// =========== PHASE 5: CHARGEMENT DES PROGRAMMES ===========

// 5.1 Programmes (*PGM uniquement)
LOAD CSV WITH HEADERS FROM 'file:///IBMi_RefArcaddesObjets.csv' AS row
WITH row 
WHERE row.LST_CELTTY = 'O' AND trim(row.LST_CTYPE) = '*PGM'
MERGE (pgm:Programme {
    name: trim(row.LST_JOBJ), 
    library: trim(row.LST_JLIB)
})
SET pgm.type = trim(row.LST_CTYPE),
    pgm.attribute = trim(row.LST_CATR),
    pgm.arcadType = trim(row.LST_CCPLT),
    pgm.description = trim(row.LST_CTXT),
    pgm.lastModified = CASE 
        WHEN row.LST_TDATE IS NOT NULL AND toString(row.LST_TDATE) <> '' 
        THEN date(substring(toString(row.LST_TDATE), 0, 4) + '-' + 
                  substring(toString(row.LST_TDATE), 4, 2) + '-' + 
                  substring(toString(row.LST_TDATE), 6, 2))
        ELSE null 
    END;

// =========== PHASE 6: CHARGEMENT DES TABLES ===========

// 6.1 Tables (*FILE avec attribut PF ou TABLE uniquement)
LOAD CSV WITH HEADERS FROM 'file:///IBMi_RefArcaddesObjets.csv' AS row
WITH row 
WHERE row.LST_CELTTY = 'O' 
  AND trim(row.LST_CTYPE) = '*FILE' 
  AND trim(row.LST_CATR) IN ['PF', 'TABLE']
MERGE (tbl:Table {
    name: trim(row.LST_JOBJ), 
    library: trim(row.LST_JLIB)
})
SET tbl.type = trim(row.LST_CTYPE),
    tbl.attribute = trim(row.LST_CATR),
    tbl.arcadType = trim(row.LST_CCPLT),
    tbl.description = trim(row.LST_CTXT),
    tbl.lastModified = CASE 
        WHEN row.LST_TDATE IS NOT NULL AND toString(row.LST_TDATE) <> '' 
        THEN date(substring(toString(row.LST_TDATE), 0, 4) + '-' + 
                  substring(toString(row.LST_TDATE), 4, 2) + '-' + 
                  substring(toString(row.LST_TDATE), 6, 2))
        ELSE null 
    END;

// =========== PHASE 7: RELATIONS BELONGS_TO ===========

// 7.1 Sources → Applications
LOAD CSV WITH HEADERS FROM 'file:///IBMi_RefArcaddesSources.csv' AS row
WITH row WHERE row.LST_CELTTY = 'M' AND trim(row.LST_CAPP) IS NOT NULL
MATCH (src:Source {
    name: trim(row.LST_JOBJ), 
    library: trim(row.LST_JLIB),
    sourceFile: trim(row.LST_JSRCF)
})
MATCH (app:Application {name: trim(row.LST_CAPP)})
MERGE (src)-[:BELONGS_TO]->(app);

// 7.2 Programmes → Applications  
LOAD CSV WITH HEADERS FROM 'file:///IBMi_RefArcaddesObjets.csv' AS row
WITH row WHERE row.LST_CELTTY = 'O' AND trim(row.LST_CTYPE) = '*PGM'
MATCH (pgm:Programme {name: trim(row.LST_JOBJ), library: trim(row.LST_JLIB)})
MATCH (app:Application {name: trim(row.LST_CAPP)})
MERGE (pgm)-[:BELONGS_TO]->(app);

// 7.3 Tables → Applications
LOAD CSV WITH HEADERS FROM 'file:///IBMi_RefArcaddesObjets.csv' AS row
WITH row WHERE row.LST_CELTTY = 'O' AND trim(row.LST_CTYPE) = '*FILE' 
               AND trim(row.LST_CATR) IN ['PF', 'TABLE']
MATCH (tbl:Table {name: trim(row.LST_JOBJ), library: trim(row.LST_JLIB)})
MATCH (app:Application {name: trim(row.LST_CAPP)})
MERGE (tbl)-[:BELONGS_TO]->(app);

// =========== PHASE 8: RELATIONS GENERATES ===========

// 8.1 Sources → Programmes (par correspondance nom/bibliothèque)
MATCH (src:Source), (pgm:Programme)
WHERE src.name = pgm.name AND src.library = pgm.library
    AND src.sourceType IN ['RPG', 'RPGLE', 'SQLRPG', 'SQLRPGLE', 'CLP', 'CLLE', 'CBL']
MERGE (src)-[:GENERATES]->(pgm);

// 8.2 Sources → Tables (par correspondance nom/bibliothèque et type de source)
MATCH (src:Source), (tbl:Table)
WHERE src.name = tbl.name AND src.library = tbl.library
    AND (src.sourceFile = 'QDDSSRC' OR src.sourceFile = 'QSQLSRC' OR src.sourceType = '*FILE')
MERGE (src)-[:GENERATES]->(tbl);

// =========== PHASE 9: RELATIONS DE TYPAGE ===========

// 9.1 TYPED_AS_IBM
MATCH (pgm:Programme), (type:TypeObjIBMi {name: pgm.type})
MERGE (pgm)-[:TYPED_AS_IBM]->(type);

MATCH (tbl:Table), (type:TypeObjIBMi {name: tbl.type})
MERGE (tbl)-[:TYPED_AS_IBM]->(type);

// 9.2 TYPED_AS_ARCAD (si le type ARCAD existe)
MATCH (pgm:Programme), (type:TypeObjARCAD {name: pgm.arcadType})
WHERE pgm.arcadType IS NOT NULL AND pgm.arcadType <> ''
MERGE (pgm)-[:TYPED_AS_ARCAD]->(type);

MATCH (tbl:Table), (type:TypeObjARCAD {name: tbl.arcadType})
WHERE tbl.arcadType IS NOT NULL AND tbl.arcadType <> ''
MERGE (tbl)-[:TYPED_AS_ARCAD]->(type);

// 9.3 HAS_ATTRIBUTE
MATCH (pgm:Programme), (attr:Attribut {name: pgm.attribute})
WHERE pgm.attribute IS NOT NULL AND pgm.attribute <> ''
MERGE (pgm)-[:HAS_ATTRIBUTE]->(attr);

MATCH (tbl:Table), (attr:Attribut {name: tbl.attribute})
WHERE tbl.attribute IS NOT NULL AND tbl.attribute <> ''
MERGE (tbl)-[:HAS_ATTRIBUTE]->(attr);

// =========== PHASE 10: RÉFÉRENCES CROISÉES (XREF) ===========

// 10.1 Relations CALLS (Programme → Programme)
LOAD CSV WITH HEADERS FROM 'file:///IBMi_RefArcaddesXREF.csv' AS row
WITH row 
WHERE trim(row.OXR_FROM_TYPE) = '*PGM' AND trim(row.OXR_TO_TYPE) = '*PGM'
    AND trim(row.OXR_FROM_OBJ) IS NOT NULL AND trim(row.OXR_TO_OBJ) IS NOT NULL
MATCH (fromPgm:Programme {name: trim(row.OXR_FROM_OBJ), library: trim(row.OXR_FROM_LIB)})
MATCH (toPgm:Programme {name: trim(row.OXR_TO_OBJ), library: trim(row.OXR_TO_LIB)})
MERGE (fromPgm)-[r:CALLS]->(toPgm)
SET r.callType = 'CALL';

// 10.2 Relations USES (Programme → Table)
LOAD CSV WITH HEADERS FROM 'file:///IBMi_RefArcaddesXREF.csv' AS row
WITH row 
WHERE trim(row.OXR_FROM_TYPE) = '*PGM' AND trim(row.OXR_TO_TYPE) = '*FILE'
    AND trim(row.OXR_FROM_OBJ) IS NOT NULL AND trim(row.OXR_TO_OBJ) IS NOT NULL
MATCH (pgm:Programme {name: trim(row.OXR_FROM_OBJ), library: trim(row.OXR_FROM_LIB)})
MATCH (tbl:Table {name: trim(row.OXR_TO_OBJ), library: trim(row.OXR_TO_LIB)})
MERGE (pgm)-[r:USES]->(tbl)
SET r.usageType = 'USE',
    r.logicalFile = CASE 
        WHEN row.OXR_TO_LF_OBJ IS NOT NULL AND trim(row.OXR_TO_LF_OBJ) <> '' 
        THEN trim(row.OXR_TO_LF_OBJ) 
        ELSE null 
    END;

// =========== PHASE 11: VALIDATION ET STATISTIQUES ===========

// 11.1 Comptage des nœuds créés
CALL {
    MATCH (app:Application) RETURN 'Applications' as Type, count(app) as Count
    UNION
    MATCH (pgm:Programme) RETURN 'Programmes' as Type, count(pgm) as Count
    UNION
    MATCH (tbl:Table) RETURN 'Tables' as Type, count(tbl) as Count
    UNION
    MATCH (src:Source) RETURN 'Sources' as Type, count(src) as Count
    UNION
    MATCH (type:TypeObjIBMi) RETURN 'Types IBMi' as Type, count(type) as Count
    UNION
    MATCH (type:TypeObjARCAD) RETURN 'Types ARCAD' as Type, count(type) as Count
    UNION
    MATCH (attr:Attribut) RETURN 'Attributs' as Type, count(attr) as Count
}
RETURN Type, Count ORDER BY Type;

// 11.2 Comptage des relations créées
CALL {
    MATCH ()-[r:BELONGS_TO]->() RETURN 'BELONGS_TO' as RelationType, count(r) as Count
    UNION
    MATCH ()-[r:GENERATES]->() RETURN 'GENERATES' as RelationType, count(r) as Count
    UNION
    MATCH ()-[r:CALLS]->() RETURN 'CALLS' as RelationType, count(r) as Count
    UNION
    MATCH ()-[r:USES]->() RETURN 'USES' as RelationType, count(r) as Count
    UNION
    MATCH ()-[r:TYPED_AS_IBM]->() RETURN 'TYPED_AS_IBM' as RelationType, count(r) as Count
    UNION
    MATCH ()-[r:TYPED_AS_ARCAD]->() RETURN 'TYPED_AS_ARCAD' as RelationType, count(r) as Count
    UNION
    MATCH ()-[r:HAS_ATTRIBUTE]->() RETURN 'HAS_ATTRIBUTE' as RelationType, count(r) as Count
}
RETURN RelationType, Count ORDER BY RelationType;

// 11.3 Identification des nœuds isolés (pour diagnostic)
MATCH (n) 
WHERE NOT (n)--() 
RETURN labels(n)[0] as NodeType, count(n) as IsolatedCount
ORDER BY IsolatedCount DESC;

// =========== PHASE 12: REQUÊTES D'ANALYSE UTILES ===========

// 12.1 Top 10 des programmes les plus appelés
MATCH (pgm:Programme)<-[:CALLS]-(caller)
RETURN pgm.name as Programme, pgm.library as Bibliotheque, 
       count(caller) as NombreAppelants
ORDER BY NombreAppelants DESC LIMIT 10;

// 12.2 Top 10 des tables les plus utilisées
MATCH (tbl:Table)<-[:USES]-(pgm)
RETURN tbl.name as Table, tbl.library as Bibliotheque, 
       count(pgm) as NombreUtilisateurs
ORDER BY NombreUtilisateurs DESC LIMIT 10;

// 12.3 Programmes sans sources identifiées
MATCH (pgm:Programme)
WHERE NOT EXISTS { MATCH (src:Source)-[:GENERATES]->(pgm) }
RETURN pgm.name as Programme, pgm.library as Bibliotheque, pgm.attribute as Type
ORDER BY pgm.name;

// =====================================================
// FIN DU SCRIPT DE CHARGEMENT
// =====================================================