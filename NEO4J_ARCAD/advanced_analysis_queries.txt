// =====================================================
// REQUÊTES D'ANALYSE AVANCÉES - PATRIMOINE IBMi
// =====================================================

// =========== 1. ANALYSES DE GOUVERNANCE ===========

// 1.1 Vue d'ensemble du patrimoine par application
MATCH (app:Application)
OPTIONAL MATCH (app)<-[:BELONGS_TO]-(pgm:Programme)
OPTIONAL MATCH (app)<-[:BELONGS_TO]-(tbl:Table)
OPTIONAL MATCH (app)<-[:BELONGS_TO]-(src:Source)
RETURN app.name as Application,
       count(DISTINCT pgm) as NombreProgrammes,
       count(DISTINCT tbl) as NombreTables,
       count(DISTINCT src) as NombreSources,
       count(DISTINCT pgm) + count(DISTINCT tbl) + count(DISTINCT src) as Total
ORDER BY Total DESC;

// 1.2 Programmes sans sources identifiées (risque de maintenance)
MATCH (pgm:Programme)
WHERE NOT EXISTS { MATCH (src:Source)-[:GENERATES]->(pgm) }
WITH pgm
MATCH (pgm)-[:BELONGS_TO]->(app:Application)
RETURN app.name as Application,
       pgm.name as Programme,
       pgm.library as Bibliotheque,
       pgm.attribute as TypeProgramme,
       pgm.description as Description
ORDER BY app.name, pgm.name;

// 1.3 Tables sans sources identifiées (données orphelines)
MATCH (tbl:Table)
WHERE NOT EXISTS { MATCH (src:Source)-[:GENERATES]->(tbl) }
WITH tbl
MATCH (tbl)-[:BELONGS_TO]->(app:Application)
RETURN app.name as Application,
       tbl.name as Table,
       tbl.library as Bibliotheque,
       tbl.attribute as TypeTable,
       tbl.description as Description
ORDER BY app.name, tbl.name;

// 1.4 Analyse de la complexité par bibliothèque
MATCH (app:Application)<-[:BELONGS_TO]-(obj)
WHERE obj:Programme OR obj:Table
WITH app.name as Application, obj.library as Bibliotheque, obj
RETURN Application, Bibliotheque,
       count(CASE WHEN obj:Programme THEN 1 END) as Programmes,
       count(CASE WHEN obj:Table THEN 1 END) as Tables,
       count(obj) as TotalObjets
ORDER BY Application, TotalObjets DESC;

// =========== 2. ANALYSES D'IMPACT ET DÉPENDANCES ===========

// 2.1 Analyse d'impact d'une table (qui utilise cette table?)
MATCH path = (tbl:Table {name: 'NOMTABLE'})<-[:USES*1..3]-(pgm:Programme)
WITH pgm, tbl, length(path) as Distance
MATCH (pgm)-[:BELONGS_TO]->(app:Application)
RETURN DISTINCT tbl.name as TableImpactee,
       tbl.library as BibliothequeTable,
       pgm.name as ProgrammeImpacte,
       pgm.library as BibliothequeProgramme,
       app.name as Application,
       Distance as NiveauImpact
ORDER BY Distance, app.name, pgm.name;

// 2.2 Cartographie des dépendances d'un programme
MATCH (pgm:Programme {name: 'NOMPROGRAMME'})
OPTIONAL MATCH (pgm)-[:CALLS]->(pgmAppele:Programme)
OPTIONAL MATCH (pgm)-[:USES]->(tblUtilisee:Table)
MATCH (pgm)-[:BELONGS_TO]->(app:Application)
RETURN pgm.name as ProgrammePrincipal,
       pgm.library as Bibliotheque,
       app.name as Application,
       collect(DISTINCT pgmAppele.name) as ProgrammesAppeles,
       collect(DISTINCT tblUtilisee.name) as TablesUtilisees,
       size(collect(DISTINCT pgmAppele.name)) as NbProgrammesAppeles,
       size(collect(DISTINCT tblUtilisee.name)) as NbTablesUtilisees;

// 2.3 Détection des cycles de dépendances (programmes qui s'appellent mutuellement)
MATCH path = (pgm1:Programme)-[:CALLS*2..5]->(pgm1)
WHERE ALL(node IN nodes(path) WHERE node:Programme)
WITH pgm1, path
MATCH (pgm1)-[:BELONGS_TO]->(app:Application)
RETURN app.name as Application,
       pgm1.name as Programme,
       pgm1.library as Bibliotheque,
       length(path) as TailleCycle,
       [n IN nodes(path) | n.name] as CheminCycle
ORDER BY TailleCycle, app.name;

// 2.4 Programmes "hub" (beaucoup d'appelants ET d'appelés)
MATCH (pgm:Programme)
OPTIONAL MATCH (pgm)<-[:CALLS]-(appelant:Programme)
OPTIONAL MATCH (pgm)-[:CALLS]->(appele:Programme)
WITH pgm, count(DISTINCT appelant) as NombreAppelants, 
     count(DISTINCT appele) as NombreAppeles
WHERE NombreAppelants > 0 AND NombreAppeles > 0
MATCH (pgm)-[:BELONGS_TO]->(app:Application)
RETURN app.name as Application,
       pgm.name as ProgrammeHub,
       pgm.library as Bibliotheque,
       NombreAppelants,
       NombreAppeles,
       NombreAppelants + NombreAppeles as ScoreConnectivite
ORDER BY ScoreConnectivite DESC LIMIT 20;

// =========== 3. ANALYSES TECHNIQUES ===========

// 3.1 Répartition des technologies utilisées
MATCH (pgm:Programme)-[:HAS_ATTRIBUTE]->(attr:Attribut)
MATCH (pgm)-[:BELONGS_TO]->(app:Application)
RETURN app.name as Application,
       attr.name as Technologie,
       count(pgm) as NombreProgrammes,
       round(100.0 * count(pgm) / count(*), 2) as Pourcentage
ORDER BY app.name, NombreProgrammes DESC;

// 3.2 Programmes utilisant du SQL embarqué
MATCH (pgm:Programme)
WHERE pgm.attribute IN ['SQLRPG', 'SQLRPGLE']
MATCH (pgm)-[:BELONGS_TO]->(app:Application)
OPTIONAL MATCH (pgm)-[:USES]->(tbl:Table)
RETURN app.name as Application,
       pgm.name as ProgrammeSQL,
       pgm.library as Bibliotheque,
       pgm.attribute as TypeSQL,
       count(DISTINCT tbl) as NombreTablesUtilisees,
       pgm.description as Description
ORDER BY app.name, NombreTablesUtilisees DESC;

// 3.3 Analyse de la taille des sources (complexité)
MATCH (src:Source)-[:GENERATES]->(pgm:Programme)
WHERE src.lineCount > 0
MATCH (pgm)-[:BELONGS_TO]->(app:Application)
RETURN app.name as Application,
       pgm.name as Programme,
       src.lineCount as NombreLignes,
       CASE 
         WHEN src.lineCount < 100 THEN 'Simple'
         WHEN src.lineCount < 500 THEN 'Moyen'
         WHEN src.lineCount < 1000 THEN 'Complexe'
         ELSE 'Très Complexe'
       END as CategorieComplexite,
       src.sourceType as TypeSource
ORDER BY src.lineCount DESC LIMIT 50;

// 3.4 Tables partagées entre applications (données transverses)
MATCH (tbl:Table)<-[:USES]-(pgm:Programme)-[:BELONGS_TO]->(app:Application)
WITH tbl, collect(DISTINCT app.name) as Applications
WHERE size(Applications) > 1
RETURN tbl.name as TablePartagee,
       tbl.library as Bibliotheque,
       Applications,
       size(Applications) as NombreApplications,
       tbl.description as Description
ORDER BY NombreApplications DESC, tbl.name;

// =========== 4. ANALYSES DE QUALITÉ ===========

// 4.1 Programmes sans description
MATCH (pgm:Programme)
WHERE pgm.description IS NULL OR pgm.description = ''
MATCH (pgm)-[:BELONGS_TO]->(app:Application)
RETURN app.name as Application,
       count(pgm) as ProgrammesSansDescription,
       collect(pgm.name)[0..10] as ExemplesProgrammes
ORDER BY ProgrammesSansDescription DESC;

// 4.2 Objets les plus anciens (par date de modification)
MATCH (obj)
WHERE (obj:Programme OR obj:Table) AND obj.lastModified IS NOT NULL
MATCH (obj)-[:BELONGS_TO]->(app:Application)
RETURN app.name as Application,
       labels(obj)[0] as TypeObjet,
       obj.name as NomObjet,
       obj.library as Bibliotheque,
       obj.lastModified as DerniereModification,
       duration.between(obj.lastModified, date()).years as AnneesSansModification
ORDER BY obj.lastModified ASC LIMIT 30;

// 4.3 Détection des noms non conformes (conventions de nommage)
MATCH (pgm:Programme)
WHERE NOT pgm.name =~ '^[A-Z]{2}[0-9]{4}.*'  // Exemple de pattern
MATCH (pgm)-[:BELONGS_TO]->(app:Application)
RETURN app.name as Application,
       pgm.name as ProgrammeNonConforme,
       pgm.library as Bibliotheque,
       'Nom non conforme au pattern' as Probleme
ORDER BY app.name, pgm.name
LIMIT 100;

// =========== 5. ANALYSES AVANCÉES AVEC GRAPHES ===========

// 5.1 Composants connectés (groupes de programmes qui communiquent)
CALL gds.wcc.stream('myGraph', {
  nodeProjection: 'Programme',
  relationshipProjection: 'CALLS'
})
YIELD nodeId, componentId
WITH gds.util.asNode(nodeId) as pgm, componentId
MATCH (pgm)-[:BELONGS_TO]->(app:Application)
RETURN componentId,
       app.name as Application,
       count(pgm) as TailleComposant,
       collect(pgm.name)[0..5] as ExemplesProgrammes
ORDER BY TailleComposant DESC;

// 5.2 Centralité (programmes les plus "centraux" dans le réseau)
CALL gds.pageRank.stream('myGraph', {
  nodeProjection: 'Programme',
  relationshipProjection: 'CALLS',
  maxIterations: 20
})
YIELD nodeId, score
WITH gds.util.asNode(nodeId) as pgm, score
MATCH (pgm)-[:BELONGS_TO]->(app:Application)
RETURN app.name as Application,
       pgm.name as Programme,
       pgm.library as Bibliotheque,
       round(score, 4) as ScoreCentralite
ORDER BY score DESC LIMIT 20;

// 5.3 Détection de communautés dans le réseau de programmes
CALL gds.louvain.stream('myGraph', {
  nodeProjection: 'Programme',
  relationshipProjection: 'CALLS'
})
YIELD nodeId, communityId
WITH gds.util.asNode(nodeId) as pgm, communityId
MATCH (pgm)-[:BELONGS_TO]->(app:Application)
RETURN communityId,
       app.name as Application,
       count(pgm) as TailleCommunaute,
       collect(pgm.name)[0..10] as ExemplesProgrammes
ORDER BY TailleCommunaute DESC;

// =========== 6. REQUÊTES DE MIGRATION ET MODERNISATION ===========

// 6.1 Candidats à la modernisation (vieilles technologies)
MATCH (pgm:Programme)-[:HAS_ATTRIBUTE]->(attr:Attribut)
WHERE attr.name IN ['RPG', 'CLP']  // Technologies anciennes
MATCH (pgm)-[:BELONGS_TO]->(app:Application)
OPTIONAL MATCH (pgm)<-[:CALLS]-(appelant:Programme)
OPTIONAL MATCH (pgm)-[:CALLS]->(appele:Programme)
RETURN app.name as Application,
       pgm.name as Programme,
       attr.name as TechnologieAncienne,
       count(DISTINCT appelant) as NombreAppelants,
       count(DISTINCT appele) as NombreAppeles,
       pgm.lastModified as DerniereModification
ORDER BY NombreAppelants DESC, pgm.lastModified ASC;

// 6.2 Impact de la suppression d'un programme
MATCH (pgm:Programme {name: 'PROGRAMME_A_SUPPRIMER'})
MATCH (pgm)<-[:CALLS*1..3]-(impact:Programme)
MATCH (impact)-[:BELONGS_TO]->(app:Application)
RETURN pgm.name as ProgrammeASupprimer,
       app.name as ApplicationImpactee,
       impact.name as ProgrammeImpacte,
       impact.library as Bibliotheque
ORDER BY app.name, impact.name;

// 6.3 Tables candidates à l'archivage (peu utilisées)
MATCH (tbl:Table)
OPTIONAL MATCH (tbl)<-[:USES]-(pgm:Programme)
WITH tbl, count(pgm) as NombreUtilisateurs
WHERE NombreUtilisateurs <= 1
MATCH (tbl)-[:BELONGS_TO]->(app:Application)
RETURN app.name as Application,
       tbl.name as TablePeuUtilisee,
       tbl.library as Bibliotheque,
       NombreUtilisateurs,
       tbl.lastModified as DerniereModification,
       tbl.description as Description
ORDER BY NombreUtilisateurs ASC, tbl.lastModified ASC;

// =========== 7. RAPPORTS DE SYNTHÈSE ===========

// 7.1 Tableau de bord exécutif
MATCH (app:Application)
OPTIONAL MATCH (app)<-[:BELONGS_TO]-(pgm:Programme)
OPTIONAL MATCH (app)<-[:BELONGS_TO]-(tbl:Table)
OPTIONAL MATCH (pgm)-[:CALLS]->(pgmAppele:Programme)
OPTIONAL MATCH (pgm)-[:USES]->(tblUtilisee:Table)
RETURN app.name as Application,
       count(DISTINCT pgm) as NombreProgrammes,
       count(DISTINCT tbl) as NombreTables,
       count(DISTINCT pgmAppele) as AppelsInterProgrammes,
       count(DISTINCT tblUtilisee) as AccesAuxTables,
       round(count(DISTINCT pgmAppele) * 1.0 / count(DISTINCT pgm), 2) as RatioComplexiteAppels
ORDER BY NombreProgrammes DESC;

// 7.2 Analyse des risques techniques
MATCH (pgm:Programme)-[:HAS_ATTRIBUTE]->(attr:Attribut)
WHERE attr.name IN ['RPG', 'CLP']  // Technologies à risque
MATCH (pgm)-[:BELONGS_TO]->(app:Application)
WITH app, count(pgm) as ProgrammesRisque
MATCH (app)<-[:BELONGS_TO]-(totalPgm:Programme)
WITH app, ProgrammesRisque, count(totalPgm) as TotalProgrammes
RETURN app.name as Application,
       ProgrammesRisque,
       TotalProgrammes,
       round(100.0 * ProgrammesRisque / TotalProgrammes, 1) as PourcentageRisque
ORDER BY PourcentageRisque DESC;

// =====================================================
// INSTRUCTIONS D'UTILISATION
// =====================================================

/*
1. Remplacez 'NOMTABLE', 'NOMPROGRAMME', etc. par les valeurs réelles
2. Adaptez les patterns de nommage selon vos conventions
3. Ajustez les seuils (nombre de lignes, dates, etc.) selon votre contexte
4. Pour les requêtes GDS (Graph Data Science), assurez-vous d'avoir :
   - Le plugin GDS installé
   - Un graphe projeté : 
     CALL gds.graph.project('myGraph', ['Programme'], ['CALLS'])
5. Sauvegardez vos requêtes personnalisées pour un usage récurrent
6. Planifiez l'exécution des rapports de gouvernance (hebdomadaire/mensuel)
*/